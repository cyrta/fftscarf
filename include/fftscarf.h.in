/*! \file

How to call:
FFTPlanSingle
FFTPlanDouble
FFTPlan (will use the default precision given by FFTScarf (selected at FFTSarf compile time))
*/

#ifndef __FFTSCARF_H__
#define __FFTSCARF_H__

#define FFTSCARF_VERSION_MAJOR 0
#define FFTSCARF_VERSION_MINOR 2
#define FFTSCARF_VERSION_REVISION 0

#cmakedefine FFTSCARF_PRECISION_SINGLE
#cmakedefine FFTSCARF_PRECISION_DOUBLE
#cmakedefine FFTSCARF_PRECISION_LONGDOUBLE
#cmakedefine FFTSCARF_PRECISION_DEFAULT @FFTSCARF_PRECISION_DEFAULT@
#cmakedefine FFTSCARF_PLAN_PROTECTACCESS

#cmakedefine FFTSCARF_FFT_IPP
#cmakedefine FFTSCARF_FFT_FFTS
#cmakedefine FFTSCARF_FFT_PFFFT
#cmakedefine FFTSCARF_FFT_FFTW3
#cmakedefine FFTSCARF_FFT_OOURA
#if FFTSCARF_PRECISION_DEFAULT == 32
    #undef OOFLOAT_SINGLE
    #define OOFLOAT_SINGLE
#elif FFTSCARF_PRECISION_DEFAULT == 64
    #undef OOFLOAT_DOUBLE
    #define OOFLOAT_DOUBLE
#elif FFTSCARF_PRECISION_DEFAULT == 128
    #undef OOFLOAT_LONGDOUBLE
    #define OOFLOAT_LONGDOUBLE
#endif
#cmakedefine FFTSCARF_FFT_FFTREAL
//#cmakedefine FFTSCARF_FFT_DJBFFT
#cmakedefine FFTSCARF_FFT_DFT

#ifdef FFTSCARF_PLAN_PROTECTACCESS
#define FFTSCARF_PLAN_ACCESS_DECLARE boost::mutex m_plan_access;
#define FFTSCARF_PLAN_ACCESS_LOCK m_plan_access.lock();
#define FFTSCARF_PLAN_ACCESS_UNLOCK m_plan_access.unlock();
#else
#define FFTSCARF_PLAN_ACCESS_DECLARE
#define FFTSCARF_PLAN_ACCESS_LOCK
#define FFTSCARF_PLAN_ACCESS_UNLOCK
#endif

// Check if GPL is enforced on the user's software
#ifdef FFTSCARF_FFT_FFTW3
    // If the FFTW3 is used, the GPL is enforced on the software.
    #define FFTSCARF_LICENSE_GPLENFORCED
#endif


#include <string>
#include <list>
#include <limits>
#include <complex>
#ifdef FFTSCARF_PLAN_PROTECTACCESS
#include <boost/thread/mutex.hpp>
#endif


/*! \brief General namespace of the wrapper library
 */
namespace fftscarf {
    //! Return the version of the library as a string.
    std::string version();

    //! Write some compile-time information to the given stream.
    void write_compile_info(std::ostream& out);

    //! Return the list of FFT libraries available.
    std::list<std::string> availableLibraries();

    //! Return the machine epsilon, that is, the difference between 1.0 and the next value representable by the floating-point type FloatType.
    template<typename FloatType>
    FloatType eps() {return std::numeric_limits<FloatType>::epsilon();}

    //! The pi value with the highest precision
    static const long double pi = 3.141592653589793238462643383279502884L;
    
    //! Return true if N is a power of 2
    bool isPow2(unsigned int N);

    //! Return true if N is of the form 2^a * 3^b * 5^c
    bool isPow235(unsigned int N);

    //! Wrap the phase value in [-pi, +pi] (TODO Speedup)
    template<typename FloatType>
    inline FloatType wrap(FloatType value){
        return std::arg(std::complex<FloatType>(std::cos(value),std::sin(value)));
    }

    //! Return a complex value from an array of two values.
    template<typename FloatType>
    inline std::complex<FloatType> make_complex(FloatType value[]){
        return std::complex<FloatType>(value[0], value[1]);
    }

    //! Return a complex value from the given real and imaginary parts.
    template<typename FloatType>
    inline std::complex<FloatType> make_complex(FloatType real, FloatType imag){
        return std::complex<FloatType>(real, imag);
    }

    /*! \brief Interface to be implemented by any FFT implementation
     * The basic idea isthe  to implement a "plan", which follows the same
     * definition as in FFTW3. Namely:
     * - A plan is either forward or backward (FFT or inverse FFT, respectively)
     * - It holds the trigonometric tables for computing an FFT of a given size.
     * - The size of the plan is not fixed and can be resized at run-time.
     * - The plan can be "executed" to tranform some given data by calling the member functions fft(.) or ifft(.)
     */
    class FFTPlanImplementation
    {
    protected:
        bool m_forward;
        int m_size;

    public:
        //! Simple constructor. By default, the plan compute the forward FFT (i.e. not the inverse FFT)
        FFTPlanImplementation(bool forward=true);
        //! A constructor for directly initializing the size of the FFT.
        FFTPlanImplementation(int n, bool forward=true);

        //! Resize the FFT plan to the given size (size restrictions may apply depending on the implementation)
        virtual void resize(int n)=0;
        //! Return the current size of the FFT plan
        int size(){return m_size;}

        // Interface to follow for implementations:
        // (these are "ghost" functions, because static polymorphism doesn't exist)
        //! Return the version of the FFT implementation
        static std::string version(){}
        //! Return the name of the FFT implementation
        static std::string libraryName(){}

        // To execute the DFT computation:
        // (these are "ghost" functions, because template polymorphism doesn't exist)
        //! Compute the forward FFT
        template<typename TypeInContainer, typename TypeOutContainer>
        void fft(const TypeInContainer& in, TypeOutContainer& out, int dftlen=-1);
        //! Compute the inverse FFT
        template<typename TypeInContainer, typename TypeOutContainer>
        void ifft(const TypeInContainer& in, TypeOutContainer& out, int winlen=-1);
    };
}

#endif // __FFTSCARF_H__

// Include files of the FFT Implementations are concatenated here below
